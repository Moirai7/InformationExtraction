<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=gbk" />
<title>plugin/dbmovie-plugin/MoviePluginImp.cpp</title>
<style>
body { margin: 0; padding: 0 }
pre { margin: 0 }
</style>
<link rel="stylesheet" type="text/css" href="../../prettify.css" />
<script type="text/javascript" src="../../prettify.js"></script>
<script type="text/javascript">
PR['registerLangHandler'](
	PR['createSimpleLexer']([
		[PR['PR_PLAIN'],/^[\r\n\f]+/, null, '\r\n\f'],
	],[
		['lang-mycode-com', /(^\+\+\+\+.*)/],
		['lang-mycode-kwd', /(^\#\#\#\#.*)/],
		['lang-mycode-str', /(^\-\-\-\-.*)/],
	]),
	['mycode']);
PR['registerLangHandler'](
	PR['createSimpleLexer']([
	],[
		['hid', /^\+\+\+\+/],
		[PR['PR_COMMENT'], /.*/],
	]),
	['mycode-com']);
PR['registerLangHandler'](
	PR['createSimpleLexer']([
	],[
		['hid', /^\#\#\#\#/],
		[PR['PR_KEYWORD'], /.*/],
	]),
	['mycode-kwd']);
PR['registerLangHandler'](
	PR['createSimpleLexer']([
	],[
		['hid', /^\-\-\-\-/],
		[PR['PR_STRING'], /.*/, null],
	]),
	['mycode-str']);
	</script>
</head>
<body onload="prettyPrint();">
	<a href="javascript:history.back()">back</a><br />
<pre class="prettyprint lang-mycode">
####     17:       #include <time.h> 
####     18:       #include <vector>
####     19:       
++++    173:           }
----    277:  -->F     if (output == NULL){
++++    282:           size_t pos_start = 0;
++++    283:    TF     while (std::string::npos != (pos_end = input.find_first_of(split,pos_start))){
++++    284:               (*output).push_back(input.substr(pos_start, pos_end - pos_start));
++++    285:               pos_start = pos_end + 1;
++++    286:           }
++++    287:  -->T     if (pos_start <= input.size() - 1){
++++    288:               (*output).push_back(input.substr(pos_start, input.size() - pos_start));
++++    289:           }
++++    290:           return (*output).size() > 0;
####    302:       
----    386:                       std::string hot_string=element[k]["viewCount"][(size_t)0].asString();
----    387:                       cur_hot=atoi(hot_string.c_str());
----    393:                   CNOTICE_LOG("k: %d cur hot:%d",k, cur_hot);
----    399:                       CNOTICE_LOG("final process_type:%s k:%d hot:%d", result_type.c_str(), k, cur_hot);
++++    522:                   jump_url=new_value;
----    532:                   jump_url=new_value;
++++    562:    TF                 if (s_entity[*iter].size() >=1 && s_entity[*iter][s_entity[*iter].size()-1].isString()) {
++++    563:                           new_value += s_entity[*iter][s_entity[*iter].size()-1].asString();
++++    564:                           CDEBUG_LOG("final_new_value is :%s\t", new_value.c_str());
++++    565:                       }
++++    567:    TF                 if (*iter == "regionalReleaseDate"){
++++    568:                           std::vector<std::string> split_result;
++++    569:                           int len = split_words(new_value, ",", &split_result);
++++    570:                           len = split_result.size();
++++    572:                           CDEBUG_LOG("regionalReleaseDate  is :%s\t",new_value.c_str());
++++    575:                               if (split_result[i].find(str)!=std::string::npos){
++++    576:                                   new_value = split_result[i].substr(0 , (split_result[i].size()-str.size()-2));
++++    577:                                   tag = 1;
++++    578:                                   break ;
++++    579:                               }
++++    580:                           }
++++    581:                           if (tag == 0){
++++    582:                               new_value = split_result[0];
++++    583:                               CDEBUG_LOG("after_process regionalReleaseDate  is :%s\t",new_value.c_str());
++++    585:                       }
++++    590:                           CDEBUG_LOG("after_process description  is :%s\t",new_value.c_str());
++++    591:                       }
++++    593:    TF                 if (*iter == "@FROM_URL"){
++++    594:                           std::vector<std::string> split_result;
++++    595:                           split_words(new_value, ",", &split_result);
++++    596:                           new_value = split_result[0] ;
++++    597:                           CDEBUG_LOG("fromurl is :%s\t",new_value.c_str());
++++    598:                       }
++++    599:                       s_entity[*iter] = new_value;
++++    601:               }
++++    602:               s_entity.toString(tmp_result);
++++    603:               CDEBUG_LOG("search result_after\t%s", tmp_result.c_str());
++++    604:  -->T         if (s_entity.isMember("_id") && (s_entity["_id"].isUInt())){
++++    686:           CNOTICE_LOG("ytx searchp search_prop \t%s\t%s", display_config.searchp.c_str(),display_config.search_prop.c_str());
++++    692:           CDEBUG_LOG("display__ytx\t%s", (*response).c_str());
++++    698:           //旅游产品时间与票价计算
++++    699:    TF     if (result_type == "Scene") {
++++    700:  -->T         if (fifadata_handle->client_name=="us" || fifadata_handle->client_name=="") {
++++    701:                   ::faci::graphsearch::Json scene_json;
++++    702:                   std::string response_str = *response;
++++    703:                   scene_json.fromString(response_str);
++++    704:  -->T             if (!scene_json.isNull() && scene_json.isMember("resultData") && scene_json["resultData"].isMember("tplData") && scene_json["resultData"]["tplData"].isMember("result") && scene_json["resultData"]["tplData"]["result"].isArray()) {
++++    705:    TF                 for (size_t i=0; i<scene_json["resultData"]["tplData"]["result"].size(); ++i) {
++++    706:                           compute_scene_pc(scene_json["resultData"]["tplData"]["result"][i]);
++++    707:                           scene_json.toString(response_str);
++++    708:                           *response = response_str;
++++    709:                       }
++++    710:                   } else {
++++    711:                       CNOTICE_LOG("The json couldn't be parsed");
++++    712:                   }
++++    713:               }
++++    714:           }
++++    715:       
++++    737:       }
####    738:       //判断当天是否属于周几到周几的星期范围
----    739:   --> bool MoviePluginImp::is_date_in_week(const struct tm *ptm,const std::string& week1,const std::string& week2) {
----    740:           std::stringstream ss;
----    741:           ss<<ptm->tm_wday;
----    742:           std::string week = ss.str();
----    743:           CDEBUG_LOG("today %s ; week1 %s ; week2 %s",week.c_str(),week1.c_str(),week2.c_str());
----    744:           return (week>=week1 && week<=week2);
----    745:       }
####    746:       //对于只有春夏秋冬没有具体时间范围的数据，判断当天是否在季节之内
----    747:   --> bool MoviePluginImp::is_date_in_season(const std::string& date,const std::string& season_str) {
----    748:   -->     if (date.size() != 4 || date > "1231") {
----    749:               return false;
----    750:           } else if (date >= "1201") {
----    751:               return season_str.find("冬") != std::string::npos;
----    752:           } else if (date >= "0901") {
----    753:               return season_str.find("秋") != std::string::npos;
----    754:           } else if (date >= "0601") {
----    755:               return season_str.find("夏") != std::string::npos;
----    756:           } else if (date >= "0301") {
----    757:               return season_str.find("春") != std::string::npos;
----    758:           } else if (date >= "0101") {
----    759:               return season_str.find("冬") != std::string::npos;
----    760:           } else {
----    761:               return false;
----    762:           }
----    763:       }
####    764:       //判断当天是否属于两个时间以内。时间数据分为两种情况，一是03~05，二是0301~0513；每种情况有两种数据，一是03~05，二是11~03，第二种数据03指的是次年
----    765:   --> bool MoviePluginImp::is_date_in_period(const std::string &date,const std::string &start,const std::string &end) {
----    766:           std::string start_date = start;
----    767:           std::string end_date = end;
----    768:           static std::string last_day[12] = {"31","29","31","30","31","30","31","31","30","31","30","31"};
----    769:   -->     if (start_date.size() == 2) {
----    770:               start_date += "01";
----    771:           }
----    772:   -->     if (end_date.size() == 2) {
----    773:               end_date += last_day[atoi(end_date.c_str())-1];
----    774:           }
----    775:           
----    776:   -->     if (start_date.size() != 4 || end_date.size() != 4) {
----    777:               return false;
----    778:           }
----    779:           
----    780:   -->     if (start_date <= end_date) {
----    781:               return start_date <= date && date <= end_date;
----    782:           } else {
----    783:               return is_date_in_period(date, start_date, "1231") || is_date_in_period(date, "0101", end_date);
----    784:           }
----    785:       }
####    786:       //判断是否在指定的节假日内
----    787:   --> bool MoviePluginImp::is_date_in_holiday(const struct tm *ptm,const std::vector<std::string> &holidays) {
----    788:           char today [9];
----    789:           strftime(today, sizeof(today), "%G%m%d",ptm);
----    790:           std::string holiday;
----    791:   -->     for (int i=0; i<holidays.size(); i++) {
----    792:               holiday += "\""+holidays[i]+"\",";
----    793:           }
----    794:           holiday.erase(holiday.end()-1);
----    795:           //节假日
----    796:           faci::knowledge::ServiceApiServerConnect* gremlinConnect = faci::knowledge::ServiceApiServerConnect::getConn();
----    797:           ::sofa::ObjectPtr __ret;
----    798:           ::sofa::ObjectPtr extra_info;
----    799:           std::string spo_query = "search_holiday(date_from_string(\""+std::string(today)+"\"), ["+holiday+"])";
----    800:           int req = gremlinConnect->computeQuery(spo_query, __ret, extra_info, "person");
----    801:           CDEBUG_LOG("sa_spo : %d", req);
----    802:           CDEBUG_LOG("spo_query : %s \t %s",holiday.c_str(), spo_query.c_str());
----    803:           std::string result = ::sofa::unbox<std::string>(__ret);
----    804:           faci::graphsearch::Json element;
----    805:           element.fromString(result);
----    806:           CDEBUG_LOG("date in result process\t%s\t%d", result.c_str(), element.size());
----    807:   -->     if (element.isNull() || !element.isMember("data") || !element["data"].isString()) {
----    808:                CWARNING_LOG("kc request to check holidays failed.");
----    809:                return false;
----    810:           } else {
----    811:   -->          return (element["data"].asString()=="true") ? true : false;
----    812:           }
----    813:       }
####    814:       //计算营业时间
----    815:   --> std::string MoviePluginImp::compute_today_openinghours(const struct tm *ptm,::faci::graphsearch::Json &structured_json) {
----    816:           ::faci::graphsearch::Json result = structured_json["openingHours"];
----    817:   -->     if (result.isNull() || !result.isArray())
----    818:           {
----    819:               CDEBUG_LOG("result is null or is not array");
----    820:               return NULL;
----    821:           }
----    822:           std::string opentime="";
----    823:           std::string closetime="";
----    824:   -->     for (size_t i=0; i<result.size(); i++)
----    825:           {
----    826:               ::faci::graphsearch::Json tmp = result[i];
----    827:               bool check_month = false;
----    828:               bool check_week = false;
----    829:               bool has_month = false;
----    830:               bool has_week = false;
----    831:   -->         if (tmp.isMember("month")) {
----    832:                   has_month = true;
----    833:                   //有具体时间范围，判断时间区间
----    834:                   char today [9];
----    835:                   strftime(today, sizeof(today), "%m%d",ptm);
----    836:                   std::string date(today);
----    837:   -->             if (tmp["month"].isMember("start") && tmp["month"].isMember("end") && tmp["month"]["start"].isString() && tmp["month"]["end"].isString() && tmp["month"]["start"].asString()!="0000" && tmp["month"]["end"].asString()!="0000") {
----    838:                       check_month = is_date_in_period(date,tmp["month"]["start"].asString(),tmp["month"]["end"].asString());
----    839:                   }else if (tmp["month"].isMember("info") && tmp["month"]["info"].isString()) {//没有具体时间范围，判断季节区间
----    840:                       check_month = is_date_in_season(date,tmp["month"]["info"].asString());
----    841:                   }
----    842:               }
----    843:               //判断星期区间
----    844:   -->         if (has_month&&check_month){
----    845:   -->             if (tmp.isMember("week")) {
----    846:                       has_week = true;
----    847:   -->                 if (tmp["week"].isMember("start") && tmp["week"].isMember("end") && tmp["week"]["start"].isString() && tmp["week"]["end"].isString()) {
----    848:                           check_week = is_date_in_week(ptm,tmp["week"]["start"].asString(),tmp["week"]["end"].asString());
----    849:                       }
----    850:                   }
----    851:               }
----    852:               
----    853:   -->         if ((has_month&&check_month)&&(has_week&&check_week)&&(tmp.isMember("hour"))) {
----    854:   -->             if (opentime=="" && tmp["hour"].isMember("opentime") && tmp["hour"]["opentime"].isString()){
----    855:                       opentime = tmp["hour"]["opentime"].asString();
----    856:                   }
----    857:   -->             if (closetime=="" && tmp["hour"].isMember("closetime") && tmp["hour"]["closetime"].isString()){
----    858:                       closetime = tmp["hour"]["closetime"].asString();
----    859:                   }
----    860:                   break;
----    861:               }
----    862:           }
----    864:   -->     if (!structured_json.isMember("specialHours")) {
----    865:   -->         if (opentime!="" && closetime!=""){
----    866:                  return opentime + "~" + closetime;
----    867:               } else {
----    868:                  return "";
----    869:               }
----    870:           }
----    871:           //有节假日信息，分为两种情况
----    872:           result = structured_json["specialHours"];
----    873:   -->     if (result.isNull() || !result.isArray())
----    874:           {
----    875:               CDEBUG_LOG("result is null or is not array");
----    876:               return "";
----    877:           }
----    878:           bool week_close = false;
----    879:   -->     for (size_t i=0; i<result.size(); i++)
----    880:           {
----    881:               ::faci::graphsearch::Json tmp = result[i];
----    882:   -->         if (tmp.isMember("type") && tmp["type"].isString() && tmp.isMember("holiday") && tmp["holiday"].isArray()) {
----    883:                   //std::string info="";
----    884:                   std::vector<std::string> holidays;
----    885:                   //关门。关门包含特殊情况，如周一关门（节假日除外），因此既是周一又是节假日需开门。
----    886:   -->             if (tmp["type"].asString()=="close") {
----    887:   -->                 for (size_t j=0; j<tmp["holiday"].size(); j++) {
----    888:   -->                     if (tmp["holiday"][j].isString()) {
----    889:   -->                         if (tmp["holiday"][j].asString().find("周")==std::string::npos){
----    890:                                   holidays.push_back(tmp["holiday"][j].asString());
----    891:                               }else {
----    892:                                   //周
----    893:                                   std::string pxq[]={"日","一","二","三","四","五","六"};
----    894:                                   std::stringstream ss;
----    895:                                   ss<<"周"<<pxq[ptm->tm_wday];
----    896:                                   std::string week = ss.str();
----    897:   -->                             week_close = (tmp["holiday"][j].asString().find(week)!=std::string::npos) ? true : week_close;
----    898:                               }
----    899:                           }
----    900:                       }
----    901:   -->                 if (!holidays.empty()) {
----    902:   -->                     if (is_date_in_holiday(ptm,holidays)) {
----    903:                               return "close";
----    904:                           }
----    905:                       }
----    906:                   }else if (tmp["type"].asString()=="open") {
----    907:                       bool check = false;
----    908:   -->                 for (size_t j=0; j<tmp["holiday"].size(); j++) {
----    909:   -->                     if (tmp["holiday"][j].isString()) {
----    910:   -->                         if (tmp["holiday"][j].asString().find("周")==std::string::npos){
----    911:                                   holidays.push_back(tmp["holiday"][j].asString());
----    912:                               }else {
----    913:                                   //周
----    914:                                   std::string pxq[]={"日","一","二","三","四","五","六"};
----    915:                                   std::stringstream ss;
----    916:                                   ss<<"周"<<pxq[ptm->tm_wday];
----    917:                                   std::string week = ss.str();
----    918:   -->                             check = (tmp["holiday"][j].asString().find(week)!=std::string::npos) ? true : check; 
----    919:                               }
----    920:                           }
----    921:                       }
----    922:   -->                 if (!holidays.empty() && !check) {
----    923:                           check = is_date_in_holiday(ptm,holidays);
----    924:                       }
----    925:   -->                 if (check) {
----    926:   -->                     if (tmp.isMember("hour")) {
----    927:   -->                         if (tmp["hour"].isMember("opentime") && tmp["hour"]["opentime"].isString()) {
----    928:                                   opentime = tmp["hour"]["opentime"].asString();
----    929:                               }
----    930:   -->                         if (tmp["hour"].isMember("closetime") && tmp["hour"]["closetime"].isString()) {
----    931:                                   closetime = tmp["hour"]["closetime"].asString();
----    932:                               }
----    933:                            }
----    934:                            return opentime + "~" + closetime;
----    935:                       }
----    936:                   }
----    937:               }
----    938:           }
----    939:   -->     if (week_close) {
----    940:               return "close";
----    941:           }
----    942:   -->     if (opentime!="" && closetime!="") {
----    943:               return opentime + "~" + closetime;
----    944:           }else
----    945:               return "";
####    947:       //计算票价
----    948:   --> std::string MoviePluginImp::compute_today_price(const struct tm *ptm, ::faci::graphsearch::Json &structured_json) {
----    949:           ::faci::graphsearch::Json result = structured_json;
----    950:   -->     if (result.isNull() || !result.isArray())
----    951:           {
----    952:               CDEBUG_LOG("result is null or is not array");
----    953:               return NULL;
----    954:           }
----    955:   -->     for (size_t i=0; i<result.size(); i++)
----    956:           {
----    957:               ::faci::graphsearch::Json tmp = result[i];
----    958:   -->         if (tmp.isMember("price") && tmp["price"].isString()) {
----    959:   -->             if (tmp.isMember("month")) {
----    960:                       //有具体时间范围，判断时间区间
----    961:                       char today [9];
----    962:                       strftime(today, sizeof(today), "%m%d",ptm);
----    963:                       std::string date(today);
----    964:   -->                 if (tmp["month"].isMember("start") && tmp["month"].isMember("end") && tmp["month"]["start"].isString() && tmp["month"]["end"].isString()) {
----    965:   -->                     if (is_date_in_period(date,tmp["month"]["start"].asString(),tmp["month"]["end"].asString())) {
----    966:                               return tmp["price"].asString();
----    967:                           }
----    968:                       //没有具体时间范围，判断季节区间
----    969:                       }else if (tmp["month"].isMember("info") && tmp["month"]["info"].isString()) {
----    970:   -->                     if (is_date_in_season(date,tmp["month"]["info"].asString())) {
----    971:                               return tmp["price"].asString();
----    972:                           } else if (tmp["month"]["info"].asString().find("淡季")!=std::string::npos) {
----    973:                               return tmp["price"].asString()+"起";
----    974:                           }
----    975:                       }
----    976:                   }else {
----    977:                       return tmp["price"].asString();
----    978:                   }
----    979:               }
----    980:           }
----    981:           CDEBUG_LOG("This result doesn't have a field named Price");
----    982:           return "";
----    983:       }
++++    985:     X void MoviePluginImp::compute_scene_pc(::faci::graphsearch::Json& scene_json) {
++++    986:    TF     if (!scene_json.isNull() && scene_json.isMember("structured_info")) {
++++    987:               ::faci::graphsearch::Json structured_json = scene_json["structured_info"];
++++    988:               std::time_t nowtime;
++++    989:               nowtime = time(NULL); //获取日历时间 
++++    990:               //struct tm *ptm=new struct tm;
++++    991:               //localtime_r(&nowtime,ptm);
++++    992:               struct tm *ptm = localtime(&nowtime);
++++    993:               // 计算当天时间和票价
----    994:  -->F         if (structured_json.isMember("openingHours")) {
----    995:                   std::string toh = compute_today_openinghours(ptm,structured_json);
----    996:   -->             if (!toh.empty()) {
----    997:                        scene_json["todayOpeningHours"] = toh;
----    998:                   }
----    999:                   CDEBUG_LOG("compute_today_openinghours end : %s",toh.c_str());
----   1000:               }
----   1001:  -->F         if (structured_json.isMember("price")) {
----   1002:                   std::string toh = compute_today_price(ptm,structured_json["price"]);
----   1003:   -->             if (!toh.empty()) {
----   1004:                        scene_json["todayPrice"] = toh;
----   1005:                   }
----   1006:                   CDEBUG_LOG("compute_today_price end : %s",toh.c_str());
----   1007:               }
++++   1008:               //delete ptm;
++++   1009:               // 提取带换行的详细时间与票价
----   1010:  -->F         if (structured_json.isMember("detailTime")) {
----   1011:                   scene_json["detailOpeningHours"] = structured_json["detailTime"].asString();
----   1012:                   CDEBUG_LOG("detailOpeningHours end : %s",structured_json["detailTime"].asString().c_str());
----   1013:               }
----   1014:  -->F         if (structured_json.isMember("detailPrice")) {
----   1015:                   scene_json["detailPrice"] = structured_json["detailPrice"].asString();
----   1016:                   CDEBUG_LOG("detailPrice end : %s",structured_json["detailPrice"].asString().c_str());
----   1017:               }
++++   1018:               scene_json.removeMember("structured_info");
++++   1019:           }
++++   1020:       }
####   1021:       

</pre>
</body>
</html>